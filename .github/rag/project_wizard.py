"""
Project Setup Wizard
Interactive wizard for setting up new projects with the Universal Context Template.

Features:
- Interactive project setup
- Generates conventions file based on user choices
- Creates .github directory structure
- Initializes RAG system
"""

import os
import sys
import json
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from pathlib import Path
from enum import Enum


class ProjectLanguage(Enum):
    """Supported project languages"""
    JAVA = "java"
    PYTHON = "python"
    TYPESCRIPT = "typescript"
    JAVASCRIPT = "javascript"
    GO = "go"
    RUST = "rust"
    CSHARP = "csharp"
    OTHER = "other"


class ProjectFramework(Enum):
    """Common frameworks"""
    # Java
    SPRING_BOOT = "Spring Boot"
    SPRING_CLOUD = "Spring Cloud"
    QUARKUS = "Quarkus"

    # Python
    FASTAPI = "FastAPI"
    DJANGO = "Django"
    FLASK = "Flask"

    # JavaScript/TypeScript
    REACT = "React"
    NEXTJS = "Next.js"
    NESTJS = "NestJS"
    EXPRESS = "Express"
    VUE = "Vue"
    ANGULAR = "Angular"

    # Other
    NONE = "None"


@dataclass
class ProjectConfig:
    """Project configuration from wizard"""
    name: str
    language: ProjectLanguage
    frameworks: List[ProjectFramework]

    # Naming conventions
    variable_style: str  # camelCase, snake_case
    function_style: str
    class_style: str
    file_style: str

    # Code style
    use_type_hints: bool
    docstring_style: str  # google, numpy, jsdoc
    max_line_length: int

    # Testing
    test_framework: str
    test_directory: str

    # Project structure
    source_directory: str

    # Security
    is_fedramp: bool

    def to_conventions_markdown(self) -> str:
        """Generate CONVENTIONS.md content"""
        md = []
        md.append("# Project Coding Conventions")
        md.append("")
        md.append(f"**Project**: {self.name}")
        md.append(f"**Language**: {self.language.value}")
        md.append(f"**Frameworks**: {', '.join(f.value for f in self.frameworks if f != ProjectFramework.NONE)}")
        md.append("")

        md.append("## Naming Conventions")
        md.append("")
        md.append("| Element | Style |")
        md.append("|---------|-------|")
        md.append(f"| Variables | `{self.variable_style}` |")
        md.append(f"| Functions | `{self.function_style}` |")
        md.append(f"| Classes | `{self.class_style}` |")
        md.append(f"| Files | `{self.file_style}` |")
        md.append("")

        md.append("## Code Style")
        md.append("")
        md.append(f"- **Type Hints**: {'Required' if self.use_type_hints else 'Optional'}")
        md.append(f"- **Docstring Style**: {self.docstring_style}")
        md.append(f"- **Max Line Length**: {self.max_line_length}")
        md.append("")

        md.append("## Testing")
        md.append("")
        md.append(f"- **Framework**: {self.test_framework}")
        md.append(f"- **Test Directory**: `{self.test_directory}`")
        md.append("")

        md.append("## Project Structure")
        md.append("")
        md.append(f"- **Source Directory**: `{self.source_directory}`")
        md.append("")

        if self.is_fedramp:
            md.append("## Security Requirements")
            md.append("")
            md.append("- FedRAMP Moderate compliance required")
            md.append("- All dependencies must be from approved sources")
            md.append("- Security scanning required before merge")
            md.append("")

        md.append("---")
        md.append("*Generated by Universal Context Template Wizard*")

        return "\n".join(md)

    def to_claude_md(self) -> str:
        """Generate CLAUDE.md content based on project config"""
        md = []
        md.append(f"# {self.name} - Development Standards")
        md.append("")
        md.append("## Naming Conventions")
        md.append("")
        md.append(f"- Variables: `{self.variable_style}` (e.g., `{'userName' if self.variable_style == 'camelCase' else 'user_name'}`)")
        md.append(f"- Functions: `{self.function_style}` (e.g., `{'getUserById' if self.function_style == 'camelCase' else 'get_user_by_id'}`)")
        md.append(f"- Classes: `{self.class_style}` (e.g., `UserService`)")
        md.append(f"- Files: `{self.file_style}` (e.g., `{'user-service' if self.file_style == 'kebab-case' else 'user_service'}`)")
        md.append("")

        md.append("## Code Quality")
        md.append("")
        if self.use_type_hints:
            md.append("- **REQUIRED**: Use type hints/annotations on all functions")
        md.append(f"- **Docstrings**: Use {self.docstring_style} style for all public functions")
        md.append(f"- **Line Length**: Maximum {self.max_line_length} characters")
        md.append("")

        md.append("## Testing Requirements")
        md.append("")
        md.append(f"- Framework: {self.test_framework}")
        md.append(f"- Test location: `{self.test_directory}/`")
        md.append("- Every new feature must have:")
        md.append("  - Unit tests for core logic")
        md.append("  - Integration tests for API endpoints")
        md.append("  - Edge case coverage")
        md.append("")

        if self.is_fedramp:
            md.append("## Security (FedRAMP)")
            md.append("")
            md.append("- NO hardcoded secrets or credentials")
            md.append("- All external API calls must use approved endpoints")
            md.append("- Logging must not contain PII or sensitive data")
            md.append("- Security scanning required before PR merge")
            md.append("")

        md.append("## Git Workflow")
        md.append("")
        md.append("- Branch naming: `feature/`, `bugfix/`, `hotfix/`")
        md.append("- Commit messages: Conventional Commits format")
        md.append("- PRs require review before merge")
        md.append("")

        return "\n".join(md)


class ProjectWizard:
    """
    Interactive project setup wizard
    """

    # Language-specific defaults
    LANGUAGE_DEFAULTS = {
        ProjectLanguage.JAVA: {
            "variable_style": "camelCase",
            "function_style": "camelCase",
            "class_style": "PascalCase",
            "file_style": "PascalCase",
            "docstring_style": "javadoc",
            "max_line_length": 120,
            "test_framework": "JUnit 5",
            "test_directory": "src/test/java",
            "source_directory": "src/main/java",
        },
        ProjectLanguage.PYTHON: {
            "variable_style": "snake_case",
            "function_style": "snake_case",
            "class_style": "PascalCase",
            "file_style": "snake_case",
            "docstring_style": "google",
            "max_line_length": 88,
            "test_framework": "pytest",
            "test_directory": "tests",
            "source_directory": "src",
        },
        ProjectLanguage.TYPESCRIPT: {
            "variable_style": "camelCase",
            "function_style": "camelCase",
            "class_style": "PascalCase",
            "file_style": "kebab-case",
            "docstring_style": "jsdoc",
            "max_line_length": 100,
            "test_framework": "Jest",
            "test_directory": "__tests__",
            "source_directory": "src",
        },
        ProjectLanguage.JAVASCRIPT: {
            "variable_style": "camelCase",
            "function_style": "camelCase",
            "class_style": "PascalCase",
            "file_style": "kebab-case",
            "docstring_style": "jsdoc",
            "max_line_length": 100,
            "test_framework": "Jest",
            "test_directory": "__tests__",
            "source_directory": "src",
        },
        ProjectLanguage.GO: {
            "variable_style": "camelCase",
            "function_style": "PascalCase",
            "class_style": "PascalCase",
            "file_style": "snake_case",
            "docstring_style": "godoc",
            "max_line_length": 120,
            "test_framework": "go test",
            "test_directory": ".",
            "source_directory": ".",
        },
        ProjectLanguage.RUST: {
            "variable_style": "snake_case",
            "function_style": "snake_case",
            "class_style": "PascalCase",
            "file_style": "snake_case",
            "docstring_style": "rustdoc",
            "max_line_length": 100,
            "test_framework": "cargo test",
            "test_directory": "tests",
            "source_directory": "src",
        },
    }

    # Framework-specific options per language
    LANGUAGE_FRAMEWORKS = {
        ProjectLanguage.JAVA: [
            ProjectFramework.SPRING_BOOT,
            ProjectFramework.SPRING_CLOUD,
            ProjectFramework.QUARKUS,
            ProjectFramework.NONE,
        ],
        ProjectLanguage.PYTHON: [
            ProjectFramework.FASTAPI,
            ProjectFramework.DJANGO,
            ProjectFramework.FLASK,
            ProjectFramework.NONE,
        ],
        ProjectLanguage.TYPESCRIPT: [
            ProjectFramework.REACT,
            ProjectFramework.NEXTJS,
            ProjectFramework.NESTJS,
            ProjectFramework.ANGULAR,
            ProjectFramework.NONE,
        ],
        ProjectLanguage.JAVASCRIPT: [
            ProjectFramework.REACT,
            ProjectFramework.EXPRESS,
            ProjectFramework.VUE,
            ProjectFramework.NONE,
        ],
    }

    def __init__(self, project_root: str):
        """
        Initialize wizard

        Args:
            project_root: Root directory for the new project
        """
        self.project_root = Path(project_root)
        self.interactive = sys.stdin.isatty()

    def run(self, config: Optional[Dict[str, Any]] = None) -> ProjectConfig:
        """
        Run the wizard

        Args:
            config: Optional pre-defined config (for non-interactive mode)

        Returns:
            ProjectConfig with user choices
        """
        if config:
            return self._from_config(config)

        if self.interactive:
            return self._run_interactive()
        else:
            return self._run_default()

    def _run_interactive(self) -> ProjectConfig:
        """Run interactive wizard"""
        print("\n" + "=" * 60)
        print("   Universal Context Template - Project Setup Wizard")
        print("=" * 60 + "\n")

        # Project name
        default_name = self.project_root.name
        name = self._prompt(f"Project name", default_name)

        # Language
        print("\nSelect primary language:")
        for i, lang in enumerate(ProjectLanguage, 1):
            if lang != ProjectLanguage.OTHER:
                print(f"  {i}. {lang.value}")
        lang_choice = self._prompt_int("Language", 2, 1, len(ProjectLanguage) - 1)
        language = list(ProjectLanguage)[lang_choice - 1]

        # Framework
        frameworks = []
        if language in self.LANGUAGE_FRAMEWORKS:
            print(f"\nSelect framework(s) for {language.value}:")
            available = self.LANGUAGE_FRAMEWORKS[language]
            for i, fw in enumerate(available, 1):
                print(f"  {i}. {fw.value}")
            fw_choice = self._prompt_int("Framework", 1, 1, len(available))
            selected_fw = available[fw_choice - 1]
            if selected_fw != ProjectFramework.NONE:
                frameworks.append(selected_fw)

        # Get defaults for language
        defaults = self.LANGUAGE_DEFAULTS.get(language, self.LANGUAGE_DEFAULTS[ProjectLanguage.PYTHON])

        # Naming conventions
        print("\nNaming conventions (press Enter for defaults):")
        variable_style = self._prompt("Variable style", defaults["variable_style"])
        function_style = self._prompt("Function style", defaults["function_style"])
        class_style = self._prompt("Class style", defaults["class_style"])
        file_style = self._prompt("File style", defaults["file_style"])

        # Code style
        print("\nCode style:")
        use_type_hints = self._prompt_bool("Require type hints", True)
        docstring_style = self._prompt("Docstring style", defaults["docstring_style"])
        max_line_length = self._prompt_int("Max line length", defaults["max_line_length"], 80, 200)

        # Testing
        print("\nTesting:")
        test_framework = self._prompt("Test framework", defaults["test_framework"])
        test_directory = self._prompt("Test directory", defaults["test_directory"])

        # Project structure
        print("\nProject structure:")
        source_directory = self._prompt("Source directory", defaults["source_directory"])

        # Security
        print("\nSecurity:")
        is_fedramp = self._prompt_bool("FedRAMP compliance required", False)

        return ProjectConfig(
            name=name,
            language=language,
            frameworks=frameworks,
            variable_style=variable_style,
            function_style=function_style,
            class_style=class_style,
            file_style=file_style,
            use_type_hints=use_type_hints,
            docstring_style=docstring_style,
            max_line_length=max_line_length,
            test_framework=test_framework,
            test_directory=test_directory,
            source_directory=source_directory,
            is_fedramp=is_fedramp,
        )

    def _run_default(self) -> ProjectConfig:
        """Run with defaults (non-interactive)"""
        defaults = self.LANGUAGE_DEFAULTS[ProjectLanguage.PYTHON]
        return ProjectConfig(
            name=self.project_root.name,
            language=ProjectLanguage.PYTHON,
            frameworks=[],
            variable_style=defaults["variable_style"],
            function_style=defaults["function_style"],
            class_style=defaults["class_style"],
            file_style=defaults["file_style"],
            use_type_hints=True,
            docstring_style=defaults["docstring_style"],
            max_line_length=defaults["max_line_length"],
            test_framework=defaults["test_framework"],
            test_directory=defaults["test_directory"],
            source_directory=defaults["source_directory"],
            is_fedramp=False,
        )

    def _from_config(self, config: Dict[str, Any]) -> ProjectConfig:
        """Create ProjectConfig from dictionary"""
        language = ProjectLanguage(config.get("language", "python"))
        defaults = self.LANGUAGE_DEFAULTS.get(language, self.LANGUAGE_DEFAULTS[ProjectLanguage.PYTHON])

        frameworks = []
        for fw_name in config.get("frameworks", []):
            try:
                frameworks.append(ProjectFramework(fw_name))
            except ValueError:
                pass

        return ProjectConfig(
            name=config.get("name", self.project_root.name),
            language=language,
            frameworks=frameworks,
            variable_style=config.get("variable_style", defaults["variable_style"]),
            function_style=config.get("function_style", defaults["function_style"]),
            class_style=config.get("class_style", defaults["class_style"]),
            file_style=config.get("file_style", defaults["file_style"]),
            use_type_hints=config.get("use_type_hints", True),
            docstring_style=config.get("docstring_style", defaults["docstring_style"]),
            max_line_length=config.get("max_line_length", defaults["max_line_length"]),
            test_framework=config.get("test_framework", defaults["test_framework"]),
            test_directory=config.get("test_directory", defaults["test_directory"]),
            source_directory=config.get("source_directory", defaults["source_directory"]),
            is_fedramp=config.get("is_fedramp", False),
        )

    def _prompt(self, prompt: str, default: str) -> str:
        """Prompt for string input"""
        try:
            result = input(f"  {prompt} [{default}]: ").strip()
            return result if result else default
        except EOFError:
            return default

    def _prompt_int(self, prompt: str, default: int, min_val: int, max_val: int) -> int:
        """Prompt for integer input"""
        try:
            result = input(f"  {prompt} [{default}]: ").strip()
            if not result:
                return default
            val = int(result)
            return max(min_val, min(max_val, val))
        except (EOFError, ValueError):
            return default

    def _prompt_bool(self, prompt: str, default: bool) -> bool:
        """Prompt for boolean input"""
        default_str = "Y/n" if default else "y/N"
        try:
            result = input(f"  {prompt} [{default_str}]: ").strip().lower()
            if not result:
                return default
            return result in ("y", "yes", "true", "1")
        except EOFError:
            return default

    def setup_project(self, config: ProjectConfig):
        """
        Set up project with the given configuration.
        IMPORTANT: Merges with existing files, never overwrites without backup.

        Args:
            config: ProjectConfig from wizard
        """
        print("\nSetting up project (preserving existing files)...")

        # Create .github directory
        claude_dir = self.project_root / ".github"
        claude_dir.mkdir(parents=True, exist_ok=True)

        # Track what we did
        created_files = []
        merged_files = []
        backed_up_files = []

        # Handle CONVENTIONS.md - merge or create
        conventions_file = claude_dir / "CONVENTIONS.md"
        new_conventions = config.to_conventions_markdown()
        self._safe_write_file(
            conventions_file, new_conventions,
            created_files, merged_files, backed_up_files,
            merge_section="## Generated Conventions"
        )

        # Handle CLAUDE.md - NEVER overwrite, only append if missing sections
        claude_md = claude_dir / "CLAUDE.md"
        new_claude_content = config.to_claude_md()
        if claude_md.exists():
            existing = claude_md.read_text()
            # Only add sections that don't exist
            sections_to_add = self._find_missing_sections(existing, new_claude_content)
            if sections_to_add:
                with open(claude_md, "a") as f:
                    f.write("\n\n# --- Auto-Generated Sections (from Wizard) ---\n")
                    f.write(sections_to_add)
                merged_files.append(str(claude_md))
                print(f"  Merged new sections into: {claude_md}")
            else:
                print(f"  Preserved existing: {claude_md} (no changes needed)")
        else:
            claude_md.write_text(new_claude_content)
            created_files.append(str(claude_md))
            print(f"  Created: {claude_md}")

        # Create commands directory (don't touch existing commands)
        commands_dir = claude_dir / "commands"
        commands_dir.mkdir(exist_ok=True)

        # Only create context-init if it doesn't exist
        context_init = commands_dir / "context-init.md"
        if not context_init.exists():
            context_init.write_text(f"""# Context Initialization

Read and understand the following project context files:

1. `.github/CLAUDE.md` - Development standards
2. `.github/CONVENTIONS.md` - Coding conventions
3. `PLANNING.md` - Project architecture (if exists)
4. `TASK.md` - Current tasks (if exists)

Project: {config.name}
Language: {config.language.value}
Frameworks: {', '.join(f.value for f in config.frameworks) or 'None'}
""")
            created_files.append(str(context_init))
            print(f"  Created: {context_init}")
        else:
            print(f"  Preserved existing: {context_init}")

        # Preserve existing agents directory
        agents_dir = claude_dir / "agents"
        if agents_dir.exists():
            agent_count = len(list(agents_dir.glob("*.md")))
            print(f"  Preserved existing: {agents_dir}/ ({agent_count} agents)")

        # Preserve existing MCP servers
        mcp_dir = claude_dir / "mcp-servers"
        if mcp_dir.exists():
            print(f"  Preserved existing: {mcp_dir}/")

        # Create RAG directory (won't touch existing)
        rag_dir = claude_dir / "rag"
        rag_dir.mkdir(exist_ok=True)

        # Handle .gitignore - append only
        gitignore = self.project_root / ".gitignore"
        gitignore_additions = """
# RAG artifacts (auto-generated)
.github/rag/chroma_db/
.github/context/
"""
        if gitignore.exists():
            content = gitignore.read_text()
            if "chroma_db" not in content:
                with open(gitignore, "a") as f:
                    f.write(gitignore_additions)
                merged_files.append(str(gitignore))
                print(f"  Appended to: {gitignore}")
            else:
                print(f"  Preserved existing: {gitignore} (already configured)")
        else:
            gitignore.write_text(gitignore_additions.strip())
            created_files.append(str(gitignore))
            print(f"  Created: {gitignore}")

        # Summary
        print("\n" + "=" * 50)
        print("Setup Summary")
        print("=" * 50)
        if created_files:
            print(f"  Created: {len(created_files)} files")
        if merged_files:
            print(f"  Merged/Appended: {len(merged_files)} files")
        if backed_up_files:
            print(f"  Backed up: {len(backed_up_files)} files (*.backup)")

        print("\nExisting AI agent files were PRESERVED.")
        print(f"\nNext steps:")
        print(f"  1. Review .github/CONVENTIONS.md")
        print(f"  2. Review any merged sections in .github/CLAUDE.md")
        print(f"  3. Run: python -m rag.adaptive_rag --project {self.project_root} --index")

    def _safe_write_file(
        self,
        file_path: Path,
        new_content: str,
        created_list: List[str],
        merged_list: List[str],
        backup_list: List[str],
        merge_section: str = None
    ):
        """
        Safely write to a file, backing up and merging if exists.

        Args:
            file_path: Path to write to
            new_content: New content to write
            created_list: List to append if file was created
            merged_list: List to append if file was merged
            backup_list: List to append if file was backed up
            merge_section: Section header to use when merging
        """
        if file_path.exists():
            existing_content = file_path.read_text()

            # Create backup
            backup_path = file_path.with_suffix(file_path.suffix + ".backup")
            backup_path.write_text(existing_content)
            backup_list.append(str(backup_path))

            if merge_section:
                # Append new content under a section
                merged_content = existing_content.rstrip()
                merged_content += f"\n\n{merge_section}\n"
                merged_content += "-" * len(merge_section) + "\n\n"
                merged_content += new_content
                file_path.write_text(merged_content)
                merged_list.append(str(file_path))
                print(f"  Merged into: {file_path} (backup: {backup_path.name})")
            else:
                # Just append
                with open(file_path, "a") as f:
                    f.write(f"\n\n# --- Auto-Generated Content ---\n{new_content}")
                merged_list.append(str(file_path))
                print(f"  Appended to: {file_path} (backup: {backup_path.name})")
        else:
            file_path.write_text(new_content)
            created_list.append(str(file_path))
            print(f"  Created: {file_path}")

    def _find_missing_sections(self, existing: str, new_content: str) -> str:
        """
        Find sections in new_content that don't exist in existing.

        Args:
            existing: Existing file content
            new_content: New content to check

        Returns:
            String with missing sections only
        """
        import re

        # Extract section headers from new content
        new_sections = re.findall(r'^## .+$', new_content, re.MULTILINE)

        missing_parts = []
        for section in new_sections:
            # Check if this section header exists in existing content
            if section not in existing:
                # Find the section content
                pattern = re.escape(section) + r'\n(.*?)(?=\n## |\Z)'
                match = re.search(pattern, new_content, re.DOTALL)
                if match:
                    missing_parts.append(f"{section}\n{match.group(1)}")

        return "\n\n".join(missing_parts)


def run_wizard(project_root: str, config: Optional[Dict[str, Any]] = None) -> ProjectConfig:
    """
    Run the project wizard

    Args:
        project_root: Path to project root
        config: Optional pre-defined config

    Returns:
        ProjectConfig
    """
    wizard = ProjectWizard(project_root)
    project_config = wizard.run(config)
    wizard.setup_project(project_config)
    return project_config


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Project Setup Wizard")
    parser.add_argument("--project", "-p", default=".", help="Project root directory")
    parser.add_argument("--config", "-c", help="JSON config file for non-interactive setup")

    args = parser.parse_args()

    config = None
    if args.config:
        with open(args.config) as f:
            config = json.load(f)

    run_wizard(args.project, config)
